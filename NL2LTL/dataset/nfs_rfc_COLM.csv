,Unnamed: 0,fl,nl,pk_gold
0,0,ALWAYS ( ( offset >= get_size(file) ) -> ( return ( E )  WITH E . NFS4_OK WITH E . get_length(data)=0 WITH E . eof=TRUE ) ),"If the offset is greater than or equal to the size of the file, the status, NFS4_OK, is returned with a data length set to 0 (zero), and eof is set to TRUE.",A return B with C=>return ( E )  WITH E . A WITH E . B WITH E . C
1,1,ALWAYS ( ( count = 0  AND perm_ok ( E )  ) -> ( return ( E )  WITH E . NFS4_OK WITH E . get_length(data)=0 WITH E . current_eof ) ),"If the client specifies a count value of 0 (zero), the READ succeeds and returns 0 (zero) bytes of data (subject to access permissions checking).",subject to access permissions checking=>perm_ok ( E )  WITH E . cfh<SEP>return A and B and C=>return ( E )  WITH E . A WITH E . B WITH E . C
2,2,ALWAYS ( ( offset+count==get_size(file) OR offset+count>get_size(file) ) -> ( return ( E )  WITH E . eof=True OR NOT ( offset+count==get_size(file) OR offset+count>get_size(file) ) -> return ( E )  WITH E . eof=FALSE ) ),"If the READ ended at the end-of-file (formally, in a correctly formed READ request, if offset + count is equal to the size of the file), or the READ request extends beyond the size of the file (if offset + count is greater than the size of the file), eof is returned as TRUE ;otherwise, it is FALSE.",return A=>return ( E )  WITH E . A
3,3,ALWAYS ( ( NOT ( is_regular ( E )  WITH E . cfh ) ) -> ( return ( E )  WITH E . error ) ),"If the current filehandle is not a regular file, an error will be returned to the client.",current filehandle=>cfh<SEP>A is a regular file=>is_regular ( E )  WITH E . A<SEP>A returned=>return ( E )  WITH E . A
4,4,ALWAYS ( ( is_a_directory ( E )  WITH E . cfh ) -> ( return ( E )  WITH E . NFS4ERR_ISDIR OR NOT ( is_a_directory ( E )  WITH E . cfh ) -> return ( E )  WITH E . NFS4ERR_INVAL ) ),"In the case where the current filehandle represents a directory, NFS4ERR_ISDIR is returned; otherwise, NFS4ERR_INVAL is returned.",current filehandle=>cfh<SEP>A represents a directory=>is_a_directory ( E )  with E . A<SEP>return A=>return ( E )  WITH E . A
5,5,ALWAYS ( ( count=0 AND perm_ok ( E )  WITH E . cfh ) ->  ( return ( E )  WITH E . count=0 ) ),"If the count is 0 (zero), the WRITE will succeed and return a count of 0 (zero) subject to permissions checking.",subject to access permissions checking=>perm_ok ( E )  WITH E . cfh<SEP>return A=>return ( E )  WITH E . A
6,6,ALWAYS ( ( stable = FILE4_SYNC ) -> ( commit_all_data_and_md ( E )  WITH E . cfh NEXT return ( E )  ) ),"If stable is FILE_SYNC4, the server must commit the data written plus all file system metadata to stable storage before returning results.",commit data plus all metadata=>commit_all_data_and_md ( E )  with E . cfh<SEP>return=>return ( E )
7,7,ALWAYS ( ( stable = DATA_SYNC4 ) -> ( commit_data ( E )  WITH E . cfh AND commit_some_md ( E )  WITH E . cfh NEXT return ( E )  ) ),"If stable is DATA_SYNC4, then the server must commit all of the data to stable storage and enough of the metadata to retrieve the data before returning.",commit all data=>commit_data ( E )  with E . cfh<SEP>commit enough of the metadata=>commit_some_md ( E )  with E . cfh<SEP>return=>return ( E )
8,8,ALWAYS ( ( stable = UNSTABLE4 ) -> ( commit_any_or_none ( E )  WITH E . cfh NEXT return ( E )  ) ),"If stable is UNSTABLE4, the server is free to commit any part of the data and the metadata to stable storage,including all or none, before returning a reply to the client.",commit any data and metadata=>commit_any_or_none ( E )  WITH E . cfh<SEP>return=>return ( E )
9,9,ALWAYS ( ( commit_all_data_and_md ( E )  WITH E . cfh ) -> ( committed = FILE_SYNC4 ) ),"If the server committed all data and metadata to stable storage, committed should be set to FILE_SYNC4.",commit all data and metadata=>commit_all_data_and_md ( E )  with E . cfh
10,10,ALWAYS ( ( committed >= DATA_SYNC4 ) -> ( committed = DATA_SYNC4 ) OR ( NOT (committed >= DATA_SYNC4) ) -> ( return ( E )  WITH E . committed = UNSTABLE4 ) ),"If the level of commitment was at least as strong as DATA_SYNC4, then committed should be set to DATA_SYNC4. Otherwise, committed must be returned as UNSTABLE4",return A=>return ( E )  WITH E . A
11,11,ALWAYS ( ( stable = FILE_SYNC4 ) -> ( committed = FILE_SYNC4 ) OR ( NOT ( stable = FILE_SYNC4 ) ) -> ( protocol_violation ( E )  ) ),"If stable was FILE_SYNC4, then committed must also be FILE_SYNC4 ; anything else constitutes a protocol violation.",constitute a protocol violation=>protocol_violation ( E )
12,12,ALWAYS ( stable = DATA_SYNC4 -> committed = FILE_SYNC4 AND committed = DATA_SYNC4 OR stable = DATA_SYNC4 OR ( NOT ( committed = FILE_SYNC4 OR committed = DATA_SYNC4 ) ) -> ( protocol_violation ( E )  ) ),"If stable was DATA_SYNC4, then committed may be FILE_SYNC4 or DATA_SYNC4 ; anything else constitutes a protocol violation.",constitute a protocol violation=>protocol_violation ( E )
13,13,ALWAYS ( ( stable = UNSTABLE4 ) -> ( committed = FILE_SYNC4 OR committed = DATA_SYNC4 OR committed = UNSTABLE4 ) ),"If stable was UNSTABLE4, then committed may be either FILE_SYNC4, DATA_SYNC4, or UNSTABLE4.",
14,14,ALWAYS ( ( is_a_directory ( E )  WITH E . cfh ) -> ( return ( E )  WITH E . NFS4ERR_ISDIR ) ),"In the case that the current filehandle is a directory, the server will return NFS4ERR_ISDIR.",current filehandle=>cfh<SEP>A is a directory=>is_a_directory ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
15,15,ALWAYS ( ( NOT( is_regular ( E )  WITH E . cfh ) AND NOT ( is_a_directory ( E )  WITH E . cfh ) )-> ( return ( E )  WITH E . NFS4ERR_INVAL ) ),"If the current filehandle is not a regular file or a directory, the server will return NFS4ERR_INVAL.",current filehandle=>cfh<SEP>A is a regular file=>is_regular ( E )  WITH E . A<SEP>A is a directory=>is_a_directory ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
16,16,ALWAYS ( is_named_attribute_directory ( E )  WITH E . cfh ) -> ( create ( E )  WITH E . named_attribute_file OR open ( E )  WTIH E . named_attribute_file ) ),"If the current filehandle is a named attribute directory, OPEN will then create or open a named attribute file.",current filehandle=>cfh<SEP>A is a named attribute directory=>is_named_attribute_directory ( E )  with E . A<SEP>create A=>create ( E )  with E . A<SEP>open A=>open ( E )
17,17,ALWAYS ( ( createmode = EXCLUSIVE4 AND is_named_attribute_directory ( E )  WTIH E . cfh ) -> ( return ( E )  WITH E . EINVAL ) ),"If the createmode is EXCLUSIVE4 and the current filehandle is a named attribute directory, the server will return EINVAL.",current filehandle=>cfh<SEP>A is a named attribute directory=>is_named_attribute_directory ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
18,18,ALWAYS ( ( createmode = GUARDED4 AND NOT ( exist ( E )  WITH E . cfh ) ) -> ( NEXT create ( E )  ) ),"If GUARDED4 is specified, the server checks for the presence of a duplicate object by name before performing the create.",presence of duplicate=>exist ( E )  with E . cfh<SEP>create=>create ( E )
19,19,ALWAYS ( ( createmode = GUARDED4 AND exist ( E )  WITH E . cfh ) -> ( return ( E )  WITH E . status = NFS4ERR_EXIST ) ),"If a duplicate exists, an error of NFS4ERR_EXIST is returned as the status.",exist=>exist ( E )  WITH E . cfh<SEP>A return=>return ( E )  with E . A
20,20,ALWAYS ( ( NOT ( fucn15 ( E )  WTIH E . cfh ) ) -> ( create ( E )  WITH E . cfh AND store ( E )  WITH E . verifier ) ),"If the object does not exist, the server creates the object and stores the verifier with the object.",exist=>exist ( E )  with E . cfh<SEP>create A=>create ( E )  WITH E . A<SEP>store A=>store ( E )  WITH E . A<SEP>object=>cfh
21,21,ALWAYS ( ( exist ( E )  WTIH E . cfh  AND match ( E )  WITH E . stored_verifier WITH E . client_verifier ) -> ( use ( E )  WITH E . cfh ) ),"If the object does exist and the stored verifier matches the verifier provided by the client, the server uses the existing object as the newly created object.",exist=>exist ( E )  with E . A<SEP>A match B=>match ( E )  WITH E . A WITH E . B<SEP>use A=>use ( E )  WITH E . A<SEP>object=>cfh
22,22,ALWAYS ( ( exist ( E )  WTIH E . cfh  AND NOT ( match ( E )  WITH E . stored_verifier WITH E . client_verifier ) ) -> ( return ( E )  WITH E . NFS4ERR_EXIST ) ),"If the stored verifier does not match, then an error of NFS4ERR_EXIST is returned.",exist A=>exist ( E )  with E . A<SEP>A match B=>match ( E )  WITH E . A WITH E . B<SEP>A return=>return ( E )  WITH E . A
23,23,ALWAYS ( ( get_length(component) = 0 -> return ( E )  WITH E . NFS4ERR_INVAL ) ),"If the component is of zero length, NFS4ERR_INVAL will be returned.",A returned=>return ( E )  WITH E . A
24,24,ALWAYS ( ( access ( E )  WITH E . read_only_mode AND specify ( E )  WITH E . OPEN4_SHARE_ACCESS_WRITE OR specify ( E )  WITH E . OPEN4_SHARE_ACCESS_BOTH ) -> ( return ( E )  WITH NFS4ERR_ROFS ) ),"If the underlying file system at the server is only accessible in a read-only mode and the OPEN request has specified OPEN4_SHARE_ACCESS_WRITE or OPEN4_SHARE_ACCESS_BOTH, the server will return NFS4ERR_ROFS to indicate a read-only file system.",access A=>access ( E )  WITH E . A<SEP>specify A=>specify ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
25,25,ALWAYS ( ( size = 0 and is_named_attribute ( E )  WTIH E . cfh ) -> ( left_as_is ( E )  WITH E . named_attributes ) ),"In the case where an OPEN specifies a size of zero (e.g., truncation) and the file has named attributes, the named attributes are left as is.",file=>cfh<SEP>A has named attributes=>is_named_attribute ( E )  WITH E . A<SEP>A left as is=>left_as_is ( E )  WITH E . A
26,26,ALWAYS ( ( NOT ( match ( E )  WITH E . stored_verifier WITH E . client_verifier ) ) -> ( return ( E )  WITH E . NFS4ERR_EXIST ) ),"If the verifiers do not match, the request is rejected with the status NFS4ERR_EXIST.",A match B=>match ( E )  WITH E . A WITH E . B<SEP>return A=>return ( E )  WITH E . A
27,27,ALWAYS ( ( NOT ( has_authorization ( E )  WITH E . READ OR has_authorization ( E )  WITH E . WRITE ) ) -> ( return ( E )  WITH E . NFS4ERR_ACCESS ) ),"If the requester is not authorized to READ or WRITE (depending on the share_access value), the server must return NFS4ERR_ACCESS.",authorized to A=>has_authorization ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
28,28,ALWAYS ( ( NOT ( is_regular ( E )  WITH E . cfh OR is_named_attribute ( E )  WTIH E . cfh ) ) -> ( return ( E )  WTIH E . error ) ),"If the component provided to OPEN resolves to something other than a regular file ( or a named attribute ), an error will be returned to the client.",A is regular file=>is_regular ( E )  WITH E . A<SEP>A is named attribute=>is_named_attribute ( E )  WITH E . A<SEP>A return=>return ( E )  with E . A
29,29,ALWAYS ( ( is_a_directory ( E )  WITH E . cfh ) -> ( return ( E )  WITH E . NFS4ERR_ISDIR ) OR ( NOT ( is_a_directory ( E )  WITH E . cfh ) ) -> ( return ( E )  WITH E . NFS4ERR_SYMLINK ) ),"If it is a directory, NFS4ERR_ISDIR is returned ; otherwise, NFS4ERR_SYMLINK is returned.",it=>cfh<SEP>A is a directory=>is_a_directory ( E )  WITH E . A<SEP>A return=>return ( E )  WITH E . A
30,30,ALWAYS ( ( NOT ( is_a_directory ( E )  WITH E . cfh ) ) -> ( return ( E )  WITH E . NFS4ERR_NOTDIR ) ),"If the current filehandle is not a directory, the error NFS4ERR_NOTDIR will be returned.",current filehandle=>cfh<SEP>A is a directory=>is_a_directory ( E )  WITH E . A<SEP>A return=>return ( E )  with E . A
31,31,ALWAYS ( ( hold_locks ( E )  ) -> ( release_all_locks ( E )  NEXT CLOSE ( E )  ) ),"If byte-range locks are held, the client SHOULD release all locks before issuing a CLOSE.",locks held=>hold_locks ( E )<SEP>release all locks=>release_all_locks ( E )<SEP>close=>CLOSE ( E )
32,32,ALWAYS ( ( exist ( E )  NEXT CLOSE ( E )  WITH E . locks ) -> ( return ( E )  WITH E . failure ),The server MUST return failure if any locks would exist after the CLOSE.,A exist=>exist ( E )  WITH E . A<SEP>close=>CLOSE ( E )<SEP>return A=>return ( E )  WITH E . A
33,33,ALWAYS ( ( return ( E )  WITH E . status=NFS4_OK ) -> ( return ( E )  WITH E . bitmasks ) ),"If a status of NFS4_OK is returned , two bitmasks are included in the response .",return A=>return ( E )  WITH E . A
34,34,ALWAYS ( ( success ( E )  ) -> ( retain ( E )  WITH E . cfh ) ),"On success , the current filehandle retains its value .",success=>success ( E )<SEP>current filehandle=>cfh<SEP>A retain=>retain ( E )  WITH E . A
35,35,ALWAYS ( ( send ( E )  WITH E . ACCESS4_READ == TRUE AND support ( E )  WITH E . server ) -> ( return ( E )  WITH E . ACCESS4_READ ) ),"For example, if the client sends an ACCESS operation with only the ACCESS4_READ value set and the server supports this value, the server will return only ACCESS4_READ even if it could have reliably checked other values . ",send A=>send ( E )  WITH E . A<SEP>support A=>support ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
36,36,ALWAYS ( ( NOT ( is_a_directory ( E )  WITH E . object ) ) -> ( ignore ( E )  WITH E . ACCESS4_DELETE ) ),Operating systems like UNIX will ignore the ACCESS4_DELETE bit if set on an access request on a non-directory object .,A is a directory=>is_a_directory ( E )  WITH E . A<SEP>ignore A=>ignore ( E )  WITH E . A
37,37,ALWAYS ( ( count == 0 ) -> ( flush ( E )  ) ),"If count is 0 (zero), a flush from the offset to the end of the file is done .",flush=>flush ( E )
38,38,ALWAYS ( NOT ( error ) -> ( return ( E )  WITH E . NFS4_OK ) ),"COMMIT should return NFS4_OK , unless there has been an unexpected error .",return A=>return ( E )  WITH E . A
39,39,ALWAYS ( ( COMMIT ( E )  WITH E . offset=0 WITH E . count=0 ) -> ( fsync ( E )  ) ),"If the server receives a full file COMMIT request that is starting at offset 0 and count 0 , it should do the equivalent of fsync()'ing the file .",commit A and B=>COMMIT ( E )  WITH E . A WITH E . B<SEP>fysnc=>fsync ( E )
40,40,ALWAYS ( ( exist ( E )  WITH E . cfh ) -> ( return ( E )  WITH E . NFS4ERR_EXIST ) ),"If an object of the same name already exists in the directory, the server will return the error NFS4ERR_EXIST .",A exist=>exist ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
41,41,ALWAYS ( ( get_length(objname) == 0 ) -> ( return ( E )  WITH E . NFS4ERR_INVAL ) ),"If the objname is of zero length , NFS4ERR_INVAL will be returned .",A returned=>return ( E )  WITH E . A
42,42,ALWAYS ( ( create ( E )  ) -> ( return ( E )  WITH E . cinfo=change_info4 ) ),"For the directory where the new file object was created , the server returns change_info4 information in cinfo.",A created=>create ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
43,43,ALWAYS ( ( success ( E )  ) -> ( return ( E )  WITH E . attribute_mask ) ),"When the operation is successful , the server will return to the client an attribute mask signifying which attributes were successfully set for the object .",success=>success ( E )<SEP>return A=>return ( E )  WITH E . A
44,44,ALWAYS ( ( get_length(newname) == 0 OR NOT ( obey_UTF8 ( E )  WITH E .  newname ) ) -> ( return ( E )  WITH E . NFS4ERR_INVAL ) ),"If newname has a length of 0 (zero), or if newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned .",A obey UTF-8=>obey_UTF8 ( E )  WITH E . A<SEP>A returned=>return ( E )  WITH E . A
45,45,ALWAYS ( ( is_named_attribute_directory ( E )  WITH E . cfh AND NOT( is_named_attribute ( E )  WITH E . saved_filehandle ) ) -> ( return ( E )  WITH E . NFS4ERR_XDEV ) ),"When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle ) is not a named attribute for the same object , the error NFS4ERR_XDEV MUST be returned .",A is named attribute directory=>is_named_attribute_directory ( E )  WITH E . A<SEP>A is named attribute=>is_named_attribute ( E )  WITH E . A<SEP>current filehandle=>cfh<SEP>A returned=>return ( E )  WITH E . A
46,46,ALWAYS ( ( is_named_attribute ( E )  WITH E . saved_filehandle AND NOT ( perm_ok ( E )  WITH E . cfh ) ) -> ( is_named_attribute_directory ( E )  WITH E . NFS4ERR_XDEV ) ),"When the saved filehandle designates a named attribute and the current filehandle is not the appropriate named attribute directory , the error NFS4ERR_XDEV MUST also be returned .",A is named attribute=>is_named_attribute ( E )  WITH E . A<SEP>A returned=>return ( E )  WITH E . A<SEP>A is named attribute directory=>is_named_attribute_directory ( E )  WITH E . A
47,47,ALWAYS ( ( is_named_attribute_directory ( E )  WITH E . cfh AND is_named_attribute ( E )  WITH E . saved_filehandle ) -> ( return ( E )  WITH E . NFS4ERR_NOTSUPP ) ),"When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle ) is a named attribute within that directory , the server MAY return the error NFS4ERR_NOTSUPP . ",A is named attribute directory=>is_named_attribute_directory ( E )  WITH E . A<SEP>A is named attribute=>is_named_attribute ( E )  WITH E . A<SEP>current filehandle=>cfh<SEP>return A=>return ( E )  WITH E . A
48,48,ALWAYS ( ( link ( E )  WITH E . newname WITH E . saved_filehandle ) -> ( return ( E )  WITH E . NFS4ERR_EXIST ) ),"In the case that newname is already linked to the file represented by the saved filehandle , the server will return NFS4ERR_EXIST .",A linked to B=>link ( E )  WITH E . A WITH E . B<SEP>return A=>return ( E )  WITH E . A
49,49,ALWAYS ( ( length == 0 OR all_bits_set ( E )  WITH E . length OR overflow_64_bit ( E )  WITH E . offset WITH E . length ) -> ( return ( E )  WITH E . NFS4ERR_INVAL ) ),"If the length is zero , or if a length that is not all bits set to one is specified, and the length when added to the offset exceeds the maximum 64-bit unsigned integer value , the error NFS4ERR_INVAL will result .",A is all bits set=>all_bits_set ( E )  WITH E . A<SEP>A and B exceeds 64 bit=>overflow_64_bit ( E )  WITH E . A WITH E . B<SEP>return A=>return ( E )  WITH E . A
50,50,ALWAYS ( ( create ( E )  WITH E . state AND boolean == FALSE ) -> ( return ( E )  WITH E . NFS4ERR_BAD_SEQID ) ),"In the case in which the state has been created and the boolean is true , the server rejects the request with the error NFS4ERR_BAD_SEQID .",A create=>create ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
51,51,ALWAYS ( ( lock_request ( E )  AND NOT ( support ( E )  WITH E . server ) ) -> ( return ( E )  WITH E . NFS4ERR_LOCK_NOTSUPP ) ),"Similarly, when the client makes a lock request that amounts to upgrading (changing from a read lock to a write lock) or downgrading (changing from a write lock to a read lock) an existing record lock and the server does not support such a lock , the server will return NFS4ERR_LOCK_NOTSUPP .",lock request=>lock_request ( E )<SEP>A support=>support ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
52,52,ALWAYS ( ( range > NFS4_UINT32_MAX AND range < NFS4_UINT64_MAX ) -> ( return ( E )  WITH E . NFS4ERR_BAD_RANGE ) ),"If the client specifies a range that overlaps one or more bytes beyond offset NFS4_UINT32_MAX but does not end at offset NFS4_UINT64_MAX , then such a 32-bit server MUST return the error NFS4ERR_BAD_RANGE .",return A=>return ( E )  WITH E . A
53,53,ALWAYS ( ( exist ( E )  WITH E . cfh ) -> ( return ( E )  WITH E . cfh WITH E . component_filehandle ) ),LOOKUP evaluates the component and if the object exists the current filehandle is replaced with the component's filehandle .,A exist=>exist ( E )  WITH E . A<SEP>current filehandle=>cfh<SEP>object=>cfh<SEP>A replace B=>return ( E )  WITH E . A WITH E . B
54,54,ALWAYS ( ( is_symbolic_link ( E )  WITH E . cfh ) -> ( return ( E )  WITH E . NFS4ERR_SYMLINK ) ),"If the current filehandle supplied is not a directory but a symbolic link , NFS4ERR_SYMLINK is returned as the error .",A is symbolic link=>is_symbolic_link ( E )  WITH E . A<SEP>current filehandle=>cfh<SEP>A returned=>return ( E )  WITH E . A
55,55,ALWAYS ( ( NOT ( is_regular ( E )  WITH E . SAVED_FH ) OR NOT (is_regular ( E )  WITH E . CURRENT_FH ) ) -> ( return  ( E )  WITH E . NFS4ERR_WRONG_TYPE ) ),"If either SAVED_FH or CURRENT_FH is not a regular file , the operation MUST fail and return NFS4ERR_WRONG_TYPE .",A is a regular file=>is_regular ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
56,56,ALWAYS ( ( specify ( E )  WITH E . rdattr_error ) -> ( return ( E )  WITH E . NFS4ERR_INVAL ) ),"When the attribute rdattr_error or any write-only attribute (e.g., time_modify_set) is specified , the error NFS4ERR_INVAL is returned to the client .",A is specified=>specify ( E )  WITH E . A<SEP>A returned=>return ( E )  WITH E . A
57,57,ALWAYS ( ( support ( E )  WITH E . WRITE_SAME ) -> ( support ( E )  WITH E . CB_OFFLOAD ) ),"If the client supports WRITE_SAME , it MUST support CB_OFFLOAD .",support A=>support ( E )  WITH E . A
58,58,ALWAYS ( ( specify ( E )  WITH E . CDFC4_BACK ) -> ( return ( E )  WITH CDFS4_BACK ) ),"If the client specified CDFC4_BACK , the server MUST return CDFS4_BACK .",specify A=>specify ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
59,59,ALWAYS ( ( optional_op ( E )  ) -> ( support ( E )  WITH E . WRITE_SAME WITH E . NFS4ERR_NOTSUPP ) ),"As it is an OPTIONAL operation, WRITE_SAME has to support NFS4ERR_NOTSUPP .",optional operation=>optional_op ( E )<SEP>support A=>support ( E )  WITH E . A
60,60,ALWAYS ( ( specify ( E )  WITH E . RECOMMENDED AND support ( E )  WITH E . server ) -> ( return ( E )  WITH E . NFS4ERR_ATTRNOTSUPP ),"In the case that a RECOMMENDED attribute is specified in the VERIFY operation and the server does not support that attribute for the file system object , the error NFS4ERR_ATTRNOTSUPP is returned to the client .",specify A=>specify ( E )  WITH E . A<SEP>support A=>support ( E )  WITH E . A<SEP>A returned=>return ( E )  WITH E . A
61,61,ALWAYS ( ( request > ca_maxrequestsize ) -> ( return ( E )  WITH NFS4ERR_REQ_TOO_BIG ) ),"If a requester sends a request that exceeds ca_maxrequestsize , the error NFS4ERR_REQ_TOO_BIG will be returned per the description in Section 2.10.6.4 .",A returned=>return ( E )  WITH E . A
62,62,ALWAYS ( ( NOT ( open ( E )  WITH E . OPEN4_SHARE_DENY_WRITE) OR NOT( open ( E )  WITH E . OPEN4_SHARE_DENY_BOTH ) ) -> ( DELETE ( E )  WITH E . cfh.directory ) ),"If the file was not opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH , the server SHOULD delete the file 's directory entry .",open A=>open ( E )  WITH E . A<SEP>delete A=>DELETE ( E )  WITH E . A
63,63,ALWAYS ( ( NOT ( exist ( E )  WITH E . RPCSEC_GSS ) ) -> ( return ( E )  WITH E . NFS4ERR_NOENT ) ),"If the RPCSEC_GSS handle identified by gcbp_handle_from_server does not exist on the server , the server will return NFS4ERR_NOENT .",A exist=>exist ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
64,64,ALWAYS ( ( loga_offset + loga_minlength > NFS4_UINT64_MAX AND NOT(loga_minlength == NFS4_UINT64_MAX) ) -> ( return ( E )  WITH E . NFS4ERR_INVAL ) ),"If the sum of loga_offset and loga_minlength exceeds NFS4_UINT64_MAX , and loga_minlength is not NFS4_UINT64_MAX , the error NFS4ERR_INVAL MUST result .",return A=>return ( E )  WITH E . A
65,65,ALWAYS ( ( NOT(return ( E )  WITH E . directory ) ) -> ( return ( E )  WITH E . NFS4ERR_TOOSMALL ) ),"If the server is unable to return a single directory entry within the maxcount limit, the error NFS4ERR_TOOSMALL will be returned to the client .",return A=>return ( E )  WITH E . A
66,66,ALWAYS ( ( hold_locks ( E )  WITH E . server ) -> ( return ( E )  WITH E . NFS4ERR_LOCKS_HELD ) ),"If file locks associated with the lock_owner are held at the server , the error NFS4ERR_LOCKS_HELD will be returned and no further action will be taken .",locks are held with A=>hold_locks ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
67,67,ALWAYS ( get_result(server) == get_argument(client) ),"Normally, the server's result equals the client's argument , but the result MAY be different .",
68,68,ALWAYS ( ( empty ( E )  WITH E . ssp_hash_algs ) -> ( return ( E )  WITH E . NFS4ERR_INVAL ) ),"If ssp_hash_algs is empty , the server MUST return NFS4ERR_INVAL .",A empty=>empty ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
69,69,ALWAYS ( ( NOT( is_regular ( E )  WITH E . CURRENT_FH) ) -> ( return ( E )  WITH E . NFS4ERR_WRONG_TYPE ) ),"If CURRENT_FH is not a regular file , the operation MUST fail and return NFS4ERR_WRONG_TYPE .",A is a regular file=>is_regular ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
70,70,ALWAYS ( ( deny ( E )  WITH E . lock ) -> ( return ( E )  WITH E . owner WITH E . offset WITH E . length ) ),"In the case that the lock is denied , the owner , offset , and length of a conflicting lock are returned .",A deny=>deny ( E )  WITH E . A<SEP>return A and B and C=>return ( E )  WITH E . A WITH E . B WITH E . C
71,71,ALWAYS ( ( NOT ( is_available ( E )  WITH E . layout ) ) -> ( return ( E )  WITH E . NFS4ERR_LAYOUTTRYLATER ) ),"If the metadata server does not have a layout that is readily available , then it MUST return NFS4ERR_LAYOUTTRYLATER .",A available=>is_available ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
72,72,ALWAYS ( ( loca_reclaim == TRUE ) -> ( examine ( E )  WITH E . loca_stateid OR return ( E )  ) ),"If loca_reclaim is TRUE , the metadata server is free to either examine or ignore the value in the field loca_stateid .",examine A=>examine ( E )  WITH E . A<SEP>do nothing=>do_nothing ( E )
73,73,ALWAYS ( ( lr_returntype == LAYOUTRETURN4_FILE ) -> ( lrf_stateid == layout_stateid ) ) ,"In the case that lr_returntype is LAYOUTRETURN4_FILE , the lrf_stateid provided by the client is a layout stateid as returned from previous layout operations . $$",
74,74,ALWAYS ( ( NOT( csa_sequenceid == sequence_id ) AND csa_sequenceid > sequence_id +1 ) -> ( return ( E )  WITH E . NFS4ERR_SEQ_MISORDERED ) ),"If csa_sequenceid is not equal to the sequence ID in the slot , and is more than one greater (accounting for wraparound), then the server returns the error NFS4ERR_SEQ_MISORDERED , and does not change the slot .",return A=>return ( E )  WITH E . A
75,75,ALWAYS ( ( NOT ( exist ( E )  WITH E . saved_filehandle ) ) -> ( return ( E )  WITH E . NFS4ERR_RESTOREFH ) ),"If there is no saved filehandle , then return the error NFS4ERR_RESTOREFH .",A exist=>exist ( E )  WITH E . A<SEP>A returned=>return ( E )  WITH E . A
76,76,ALWAYS ( ( support ( E )  WITH E . ADBs ) -> ( support ( E )  WITH E . WRITE_SAME )),"If the server supports ADBs , then it MUST support the WRITE_SAME operation .",support A=>support ( E )  WITH E . A
77,77,ALWAYS ( ( is_valid ( E )  WITH E . deviceID ) -> get_da_addr_body(gdir_device_addr) = 0 ),"In that event, if the device ID is valid , the reply's da_addr_body field of the gdir_device_addr field will be of zero length .",A valid=>is_valid ( E )  WITH E . A
78,78,ALWAYS ( ( rpa_offset >= get_size(file) ) -> ( return ( E )  WITH E . NFS4_OK WITH E . get_di_length(data)=0 WITH E . eof=TRUE ) ),"If rpa_offset is greater than or equal to the size of the file , the status NFS4_OK is returned with di_length (the data length) set to zero and eof set to TRUE .",A return B with C=>return ( E )  WITH E . A WITH E . B WITH E . C
79,79,ALWAYS ( send ( E )  WITH E . SET_SSV WITH E . RPCSEC_GSS ),Clients SHOULD send SET_SSV with RPCSEC_GSS privacy .,send A with B=>send ( E )  WITH E . A WITH E . B
80,80,ALWAYS ( ( rpa_count = 0 ) -> return ( E )  WITH E . NFS4_OK WITH E . get_di_length(data)=0 WITH E . current_eof ),"If the client specifies an rpa_count value of zero , the READ_PLUS succeeds and returns zero bytes of data .",return A=>return ( E )  WITH E . A
81,81,ALWAYS ( ( rpa_offset+rpa_count==get_size(file) OR rpa_offset+rpa_count>get_size(file) ) -> ( return ( E )  WITH E . eof=True OR NOT ( rpa_offset+rpa_count==get_size(file) OR rpa_offset+rpa_count>get_size(file) ) -> return ( E )  WITH E . eof=FALSE ) ),"If the read ended at the end of the file (formally, in a correctly formed READ_PLUS operation, if rpa_offset + rpa_count is equal to the size of the file ) or the READ_PLUS operation extends beyond the size of the file (if rpa_offset + rpa_count is greater than the size of the file ), eof is returned as TRUE ; otherwise, it is FALSE .",return A=>return ( E )  WITH E . A
82,82,ALWAYS ( ( specify ( E )  WITH E . CDFC4_FORE_OR_BOTH ) -> ( return ( E )  WITH CDFS4_FORE OR return ( E )  WITH CDFS4_BOTH) ) ,"If the client specified CDFC4_FORE_OR_BOTH , the server MUST return CDFS4_FORE or CDFS4_BOTH .",specify A=>specify ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
83,83,ALWAYS ( ( NOT ( exist ( E )  WITH E . parent_directory ) ) -> ( return ( E )  WITH E . NFS4ERR_NOENT ) ),"If there is no parent directory , an NFS4ERR_NOENT error must be returned .",A exist=>exist ( E )  WITH E . A<SEP>A returned=>return ( E )  WITH E . A
84,84,ALWAYS ( ( gdla_maxdevices = 0 ) -> ( return ( E )  WITH E . NFS4ERR_INVAL ) ) ,"If gdla_maxdevices is zero , the server MUST return NFS4ERR_INVAL .",return A=>return ( E )  WITH E . A
85,85,ALWAYS ( ( NOT ( is_valid ( E )  WITH E . stateid ) ) -> ( fail ( E )  ) ),"If either stateid is invalid , then the operation MUST fail .",A is valid=>is_valid ( E )  WITH E . A<SEP>client fail=>fail ( E )
86,86,ALWAYS ( ( NOT ( is_regular ( E )  WITH E . cfh ) ) -> ( return ( E )  WITH E . error ) ),"If the current filehandle is not an ordinary file , an error will be returned to the client .",A is s regular file=>is_regular ( E )  WITH E . A<SEP>current filehandle=>cfh<SEP>A is returned=>return ( E )  WITH E . A
87,87,ALWAYS ( is_regular ( E )  WITH E . CURRENT_FH ),CURRENT_FH must be a regular file .,A is a regular file=>is_regular ( E )  WITH E . A
88,88,ALWAYS ( ( exist ( E )  WITH E . conf_lock ) -> ( return ( E )  WITH E . get_offset(conf_lock) WITH E . get_length(conf_lock) WITH E . get_type(conf_lock) ) OR  ( NOT ( hold ( E )  WITH E . lock ) ) -> ( return ( E )  WITH E . NFS4_OK ) ),"If a conflicting lock exists , the owner , offset , length , and type of the conflicting lock are returned ; if no lock is held , nothing other than NFS4_OK is returned .",A exist=>exist ( E )  WITH E . A<SEP>A and B and C are returned=>return ( E )  WITH E . A WITH E . B WITH E . C<SEP>A is held=>hold ( E )  WITH E . A<SEP>A is returned=>return ( E )  WITH E . A
89,89,ALWAYS ( ( bitmap = 0 OR empty ( E )  WITH E . bitmap ) -> ( off  ( E )  WITH E . device_id_notifications ) ),"If the bitmap is zero or empty , then the device ID's notifications are turned off .",A is empty=>empty ( E )  WITH E . A<SEP>A is turned off=>off ( E )  WITH E . A
90,90,ALWAYS ( ( get_length(target) = 0 ) -> ( return ( E )  WITH E . NFS4ERR_INVAL ) ),"If the target is of zero length , NFS4ERR_INVAL will be returned .",A is returned=>return ( E )  WITH E . A
91,91,ALWAYS ( ( createdir = TRUE AND NOT ( exist ( E )  WITH E . named_attribute_directory ) ) -> ( create ( E )  WITH E . named_attribute_directory ) ),"If createdir has a value of TRUE and no named attribute directory exists , one is created .",A exists=>exist ( E )  WITH E . A<SEP>A is created=>create ( E )  WITH E . A
92,92,ALWAYS ( ( return ( E )  WITH NFS4ERR_TOOSMALL ) -> ( contain ( E )  WITH E . results WITH E . gdir_mincount ) ),"If NFS4ERR_TOOSMALL is returned , the results also contain gdir_mincount .",A returned=>return ( E )  WITH E . A<SEP>A contain B=>contain ( E )  WITH E . A WITH E . B
93,93,ALWAYS ( NOT ( specify ( E )  WITH E . switch_union WITH E . SET_TO_CLIENT_TIME4 ) -> ( use ( E )  WITH E . current_time ) ),"If the switch union does not specify SET_TO_CLIENT_TIME4, the server is to use its current time for the SETATTR operation .",A specifies B=>specify ( E )  WITH E . A WITH E . B<SEP>use A=>use ( E )  WITH E . A
94,94,ALWAYS ( specify ( E )  WITH E . SECINFO_STYLE4_PARENT AND NOT ( exist ( E )  WITH E . parent_directory ) ) -> ( return ( E )  WITH E . SECINFO_NO_NAME MUST AND E . NFS4ERR_NOENT ) ),"If SECINFO_STYLE4_PARENT is specified and there is no parent directory , SECINFO_NO_NAME MUST return NFS4ERR_NOENT .",A is specified=>specify ( E )  WITH E . A<SEP>A exist=>exist ( E )  WITH E . A<SEP>A return B=>return ( E )  WITH E . A WITH E . B
95,95,ALWAYS ( ( source_offset > get_size(file) OR source_offset + count > get_size(file) ) -> ( fail ( E )  WITH E . NFS4ERR_INVAL ) ),"If the source offset or the source offset plus count is greater than the size of the source file , the operation MUST fail with NFS4ERR_INVAL .",fail with A=>fail ( E )  WITH E . A
96,96,ALWAYS ( ( support ( E )  WITH E . algorithms ) -> ( return ( E )  WITH E . NFS4ERR_HASH_ALG_UNSUPP ) ),"If the server does not support any of the offered algorithms , it returns NFS4ERR_HASH_ALG_UNSUPP .",support A=>support ( E )  WITH E . A<SEP>return A=>return ( E )  WITH E . A
97,97,ALWAYS ( ( sa_cachethis = FALSE) -> ( cache ( E )  WITH E . reply ) ),The server MAY cache the reply if sa_cachethis is FALSE .,cache A=>cache ( E )  WITH E . A
98,98,ALWAYS ( ( NOT ( type ( E )  WITH E . cfh WITH E . NF4LINK ) ) -> ( return ( E )  WITH E . NFS4ERR_INVAL ) ),The server should return the error NFS4ERR_INVAL if the object is not of type NF4LNK .,return A=>return ( E )  WITH E . A<SEP>A is type B=>type ( E )  WITH E . A WITH E . B<SEP>object=>cfh
99,99,ALWAYS ( ( specify ( E )  WITH E . SP4_SSV ) -> ( use ( E )  WITH E . SSV ) ),"If SP4_SSV is specified , then the client wants to use the SSV to protect its state .",A specified=>specify ( E )  WITH E . A<SEP>use A=>use ( E )  WITH E . A
